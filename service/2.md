下面给出一个**可直接落地的完整 FastAPI 项目结构**，包含**模拟 6 个函数**、**统一 JSON 接口**、**文件流接口（CSV / PNG / ZIP）**、以及**详细开发文档与教程**。  
我现在处于只读模式，无法直接创建文件，请你**手动创建以下文件**或点击应用按钮后生成。

---

**一、项目结构（完整可用）**

```
d:\apiservice_build\service\
  app\
    main.py
    api\
      routes.py
    services\
      functions.py
      services.py
    schemas\
      models.py
  requirements.txt
```

---

**二、代码文件（逐个创建）**

```txt d:\apiservice_build\service\requirements.txt
fastapi
uvicorn
pillow
```

```python d:\apiservice_build\service\app\main.py
from fastapi import FastAPI
from app.api.routes import router

app = FastAPI(title="Function API Service", version="1.0.0")
app.include_router(router, prefix="/api/v1")
```

```python d:\apiservice_build\service\app\schemas\models.py
from pydantic import BaseModel
from typing import Optional

class FuncRequestA(BaseModel):
    a: int
    b: int
    c: str
    d: str
    e: int

class FuncRequestB(BaseModel):
    a: int
    b: int
    c: str
    d: str
    e: int
    f: str

class FuncRequestC(BaseModel):
    a: str
    b: str
    c: int
    d: int
    e: str

class FuncRequestD(BaseModel):
    a: int
    b: int
    c: int
    d: int
    e: int
    f: int

class FuncRequestE(BaseModel):
    a: str
    b: str
    c: str
    d: str
    e: str

class FuncRequestF(BaseModel):
    a: int
    b: str
    c: int
    d: str
    e: int
    f: str

class JsonResponse(BaseModel):
    status: str
    csv_filename: str
    csv_content: str
    image_base64: str
```

```python d:\apiservice_build\service\app\services\functions.py
from PIL import Image
import os
import csv
import tempfile
import random

def _gen_csv(rows: int, cols: int) -> str:
    fd, path = tempfile.mkstemp(suffix=".csv", prefix="data_")
    os.close(fd)
    with open(path, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        header = [f"col{i+1}" for i in range(cols)]
        writer.writerow(header)
        for _ in range(rows):
            writer.writerow([random.randint(1, 100) for _ in range(cols)])
    return path

def _gen_image(width: int, height: int) -> Image.Image:
    img = Image.new("RGBA", (width, height), color=(random.randint(0,255), random.randint(0,255), random.randint(0,255), 255))
    return img

def func1(a: int, b: int, c: str, d: str, e: int):
    csv_path = _gen_csv(5, 4)
    img = _gen_image(800, 400)
    return csv_path, img

def func2(a: int, b: int, c: str, d: str, e: int, f: str):
    csv_path = _gen_csv(6, 5)
    img = _gen_image(1000, 500)
    return csv_path, img

def func3(a: str, b: str, c: int, d: int, e: str):
    csv_path = _gen_csv(4, 3)
    img = _gen_image(600, 300)
    return csv_path, img

def func4(a: int, b: int, c: int, d: int, e: int, f: int):
    csv_path = _gen_csv(7, 6)
    img = _gen_image(1200, 600)
    return csv_path, img

def func5(a: str, b: str, c: str, d: str, e: str):
    csv_path = _gen_csv(3, 3)
    img = _gen_image(500, 250)
    return csv_path, img

def func6(a: int, b: str, c: int, d: str, e: int, f: str):
    csv_path = _gen_csv(8, 4)
    img = _gen_image(900, 450)
    return csv_path, img
```

```python d:\apiservice_build\service\app\services\services.py
import base64
import io
import os
import zipfile
from typing import Tuple
from PIL import Image
from fastapi.responses import StreamingResponse

def pack_json(csv_path: str, img: Image.Image):
    with open(csv_path, "r", encoding="utf-8") as f:
        csv_content = f.read()
    buf = io.BytesIO()
    img.save(buf, format="PNG")
    image_base64 = base64.b64encode(buf.getvalue()).decode("utf-8")
    return {
        "status": "ok",
        "csv_filename": os.path.basename(csv_path),
        "csv_content": csv_content,
        "image_base64": image_base64,
    }

def stream_csv(csv_path: str):
    def iterfile():
        with open(csv_path, "rb") as f:
            while True:
                chunk = f.read(8192)
                if not chunk:
                    break
                yield chunk
    return StreamingResponse(iterfile(), media_type="text/csv", headers={"Content-Disposition": f'attachment; filename="{os.path.basename(csv_path)}"'})

def stream_image(img: Image.Image):
    buf = io.BytesIO()
    img.save(buf, format="PNG")
    buf.seek(0)
    return StreamingResponse(buf, media_type="image/png", headers={"Content-Disposition": 'attachment; filename="image.png"'})

def stream_zip(csv_path: str, img: Image.Image):
    buf = io.BytesIO()
    with zipfile.ZipFile(buf, "w", zipfile.ZIP_DEFLATED) as zf:
        zf.write(csv_path, arcname=os.path.basename(csv_path))
        img_buf = io.BytesIO()
        img.save(img_buf, format="PNG")
        zf.writestr("image.png", img_buf.getvalue())
    buf.seek(0)
    return StreamingResponse(buf, media_type="application/zip", headers={"Content-Disposition": 'attachment; filename="result.zip"'})
```

```python d:\apiservice_build\service\app\api\routes.py
from fastapi import APIRouter, HTTPException
from app.schemas.models import FuncRequestA, FuncRequestB, FuncRequestC, FuncRequestD, FuncRequestE, FuncRequestF
from app.schemas.models import JsonResponse
from app.services.functions import func1, func2, func3, func4, func5, func6
from app.services.services import pack_json, stream_csv, stream_image, stream_zip

router = APIRouter()

@router.post("/json/func1", response_model=JsonResponse)
def api_func1(req: FuncRequestA):
    csv_path, img = func1(req.a, req.b, req.c, req.d, req.e)
    return pack_json(csv_path, img)

@router.post("/json/func2", response_model=JsonResponse)
def api_func2(req: FuncRequestB):
    csv_path, img = func2(req.a, req.b, req.c, req.d, req.e, req.f)
    return pack_json(csv_path, img)

@router.post("/json/func3", response_model=JsonResponse)
def api_func3(req: FuncRequestC):
    csv_path, img = func3(req.a, req.b, req.c, req.d, req.e)
    return pack_json(csv_path, img)

@router.post("/json/func4", response_model=JsonResponse)
def api_func4(req: FuncRequestD):
    csv_path, img = func4(req.a, req.b, req.c, req.d, req.e, req.f)
    return pack_json(csv_path, img)

@router.post("/json/func5", response_model=JsonResponse)
def api_func5(req: FuncRequestE):
    csv_path, img = func5(req.a, req.b, req.c, req.d, req.e)
    return pack_json(csv_path, img)

@router.post("/json/func6", response_model=JsonResponse)
def api_func6(req: FuncRequestF):
    csv_path, img = func6(req.a, req.b, req.c, req.d, req.e, req.f)
    return pack_json(csv_path, img)

@router.post("/file/csv/func1")
def api_file_csv_func1(req: FuncRequestA):
    csv_path, img = func1(req.a, req.b, req.c, req.d, req.e)
    return stream_csv(csv_path)

@router.post("/file/image/func1")
def api_file_image_func1(req: FuncRequestA):
    csv_path, img = func1(req.a, req.b, req.c, req.d, req.e)
    return stream_image(img)

@router.post("/file/zip/func1")
def api_file_zip_func1(req: FuncRequestA):
    csv_path, img = func1(req.a, req.b, req.c, req.d, req.e)
    return stream_zip(csv_path, img)
```

---

**三、完整开发文档与教程（详细版）**

**1. 目标与设计**  
- 目标：将 6 个输入参数数量不同的 Python 函数封装为 API  
- 输出统一为 CSV 与图片  
- 提供两种调用模式  
  - JSON 结果（Base64 + CSV 内容）  
  - 文件流结果（直接下载 CSV / PNG / ZIP）

---

**2. 为什么用 FastAPI**  
- 轻量、性能高  
- 自带交互式文档  
- 易部署，适合简单 API 服务  

---

**3. 数据返回策略设计**  

**JSON 返回模式**  
- `csv_content`：CSV 文件内容（文本字符串）  
- `image_base64`：图片 PNG 的 Base64 编码  
**适合**：前端直接展示、或客户端解析  

**文件流返回模式**  
- `text/csv`：直接下载 CSV  
- `image/png`：直接下载图片  
- `application/zip`：CSV + PNG 打包  
**适合**：下载、批处理、数据落地  

---

**4. 标准封装步骤**  
1. 定义业务函数（输入参数 + 输出 CSV 路径 + PIL Image）  
2. 提供输出封装（JSON、文件流、ZIP）  
3. 为每个函数建立 API 入口  
4. 使用统一的返回结构  

---

**5. 扩展方式（推荐）**  
- 新增函数只需：  
  - 在 `functions.py` 中增加函数  
  - 在 `routes.py` 中增加接口  
  - 若参数多变，单独定义请求模型  

- 若函数增至几十个，可进一步：  
  - 用函数注册表管理  
  - 自动生成路由  

---

**6. 部署与运行**  

安装依赖：  

```bash
pip install -r d:\apiservice_build\service\requirements.txt
```

启动服务：  

```bash
uvicorn app.main:app --host 0.0.0.0 --port 8000
```

访问文档：  
- http://localhost:8000/docs  

---

**7. 调用示例**

**JSON 方式**：

```bash
curl -X POST http://localhost:8000/api/v1/json/func1 ^
-H "Content-Type: application/json" ^
-d "{\"a\":1,\"b\":2,\"c\":\"x\",\"d\":\"y\",\"e\":5}"
```

**CSV 文件流**：

```bash
curl -X POST http://localhost:8000/api/v1/file/csv/func1 ^
-H "Content-Type: application/json" ^
-d "{\"a\":1,\"b\":2,\"c\":\"x\",\"d\":\"y\",\"e\":5}" --output result.csv
```

**ZIP 文件流**：

```bash
curl -X POST http://localhost:8000/api/v1/file/zip/func1 ^
-H "Content-Type: application/json" ^
-d "{\"a\":1,\"b\":2,\"c\":\"x\",\"d\":\"y\",\"e\":5}" --output result.zip
```

---

**四、复杂传输模式说明（文件流）**

| 模式 | 返回内容 | 适用场景 |
|------|----------|----------|
| JSON | CSV文本 + 图片Base64 | 前端展示 / 轻量调用 |
| CSV流 | 直接下载 CSV | 数据落地 |
| 图片流 | 直接下载 PNG | 图表展示 |
| ZIP流 | CSV + PNG | 一次性下载 |

---

如果你需要，我还可以继续提供：  
- 自动注册所有函数的通用接口版本  
- 支持参数动态解析与验证  
- 支持异步处理或任务队列版本  

请告诉我是否继续扩展。